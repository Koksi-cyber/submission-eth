"""
labeler.py
This module assigns binary win/loss labels to each entry candle based on a
forward scan of future price action.  Labels are generated by comparing the
maximum high and minimum low over a finite horizon against dynamically
calculated take‑profit and liquidation price thresholds.  If the low
within the horizon falls below the liquidation price the trade is marked as a
loss (0).  If the high rises above the take‑profit price before that happens
it is marked as a win (1).  If neither condition is met within the horizon
the trade is considered a loss by default.  A longer horizon will better
approximate an unconstrained forward scan at the expense of computation time.

For training purposes a reasonable horizon (e.g. 60–120 candles) often
provides a good compromise between accuracy and efficiency.  For live
backtesting we instead perform an unbounded scan for each trade triggered by
the model, which is feasible because the number of executed trades is much
smaller than the number of available candles.
"""

from typing import Tuple
import numpy as np
import pandas as pd

# Import from sibling module when running as a script (not as a package)
from calc import TradeParams, calc_quantity, calc_take_profit_price, calc_liquidation_price


def compute_future_extremes(high: np.ndarray, low: np.ndarray, horizon: int) -> Tuple[np.ndarray, np.ndarray]:
    """Compute per‑candle max(high) and min(low) over the next ``horizon`` candles.

    Parameters
    ----------
    high : np.ndarray
        Array of high prices.
    low : np.ndarray
        Array of low prices.
    horizon : int
        Number of future candles to consider.  For candle ``i`` the
        extreme is computed over ``i+1`` up to ``i+horizon`` inclusive.

    Returns
    -------
    Tuple[np.ndarray, np.ndarray]
        Two arrays of length ``len(high)`` containing the maximum highs and
        minimum lows within the forward window for each candle.  The last
        few rows near the end of the series will simply reflect the
        extremes up to the end of the array.
    """
    n = len(high)
    max_high = np.empty(n)
    min_low = np.empty(n)
    for i in range(n):
        start = i + 1
        end = min(i + horizon + 1, n)
        if start < end:
            window_high = high[start:end]
            window_low = low[start:end]
            max_high[i] = np.max(window_high)
            min_low[i] = np.min(window_low)
        else:
            # No future candles: treat extremes as current values
            max_high[i] = high[i]
            min_low[i] = low[i]
    return max_high, min_low


def label_dataset(
    df: pd.DataFrame,
    horizon: int = 60,
    params: TradeParams = TradeParams(),
) -> pd.DataFrame:
    """Assign win/loss labels and target prices to each candle in ``df``.

    The returned DataFrame contains the following new columns:

    ``quantity`` – position size in ETH
    ``p_liq`` – liquidation price
    ``p_tp`` – take‑profit price
    ``label`` – 1 for a win, 0 for a loss (approximate)

    The calculation uses only data up to and including the current candle and
    looks ahead a finite number of candles (``horizon``) when determining
    whether the future high or low crosses the respective threshold.  A longer
    horizon improves label quality but increases runtime.  Any rows with NaN
    values in required columns are returned unlabelled.
    """
    df = df.copy()
    # Ensure price columns are numeric
    for col in ['open', 'high', 'low', 'close']:
        df[col] = df[col].astype(float)

    # Compute quantity, liquidation and take profit for each candle
    prices = df['close'].to_numpy()
    quantities = (params.margin * params.leverage) / prices
    notionals = prices * quantities
    # P_liq = entry + (MM - margin + N * fee) / Q, where MM = N * mmr
    mm = notionals * params.mmr
    p_liq = prices + (mm - params.margin + notionals * params.taker_fee) / quantities
    # P_tp = entry + (profit + N * fee * 2) / Q
    p_tp = prices + (params.profit_target + notionals * params.taker_fee * 2) / quantities

    df['quantity'] = quantities
    df['p_liq'] = p_liq
    df['p_tp'] = p_tp

    # Compute future extremes
    max_high, min_low = compute_future_extremes(df['high'].to_numpy(), df['low'].to_numpy(), horizon)

    labels = np.zeros(len(df), dtype=np.int8)
    for i in range(len(df)):
        # Loss if price hits liquidation level at any point
        if min_low[i] <= p_liq[i]:
            labels[i] = 0
        # Win if price hits take profit level first
        elif max_high[i] >= p_tp[i]:
            labels[i] = 1
        else:
            labels[i] = 0
    df['label'] = labels
    return df


def backtest_trade(
    prices_df: pd.DataFrame,
    entry_index: int,
    params: TradeParams,
    ) -> Tuple[int, float, float, float, int]:
    """Perform an unbounded forward scan for a single trade.

    Parameters
    ----------
    prices_df : pd.DataFrame
        The full minute‑level OHLCV DataFrame used for backtesting.  Must
        include at least ``high`` and ``low`` columns.
    entry_index : int
        The index into ``prices_df`` representing the candle where the trade
        is opened.
    params : TradeParams
        Trading parameters defining margin, leverage and profit target.

    Returns
    -------
    Tuple[int, float, float, float, int]
        (label, exit_price, pnl, take_profit_price, exit_index)

    label
        1 if the trade hits the take‑profit price before liquidation, 0
        otherwise.
    exit_price
        The price at which the trade closed (P_tp or P_liq).
    pnl
        The profit or loss in USDT at exit.
    take_profit_price
        The computed take‑profit price (for reference).
    exit_index
        The index of the candle on which the trade closed.

    Notes
    -----
    The backtest uses an unbounded scan (i.e. it will search until the end of
    the DataFrame) to determine which threshold is hit first.  Because this
    function is only called for trades actually taken (filtered by the model
    probability) the computational cost is manageable.
    """
    row = prices_df.iloc[entry_index]
    entry_price = float(row['close'])
    q, p_liq, p_tp, _ = params.compute_all(entry_price)
    # Scan forward
    for i in range(entry_index + 1, len(prices_df)):
        high = float(prices_df.iloc[i]['high'])
        low = float(prices_df.iloc[i]['low'])
        if low <= p_liq:
            exit_price = p_liq
            pnl = -params.margin  # full margin lost
            return 0, exit_price, pnl, p_tp, i
        if high >= p_tp:
            exit_price = p_tp
            pnl = params.profit_target  # profit target (net)
            return 1, exit_price, pnl, p_tp, i
    # If we reach the end of the dataset without hitting either level
    # treat as a loss; exit at final close price and compute actual pnl
    final_close = float(prices_df.iloc[-1]['close'])
    pnl = q * (final_close - entry_price) - (entry_price * q) * params.taker_fee * 2
    return 0, final_close, pnl, p_tp, len(prices_df) - 1